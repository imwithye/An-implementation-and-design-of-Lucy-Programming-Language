%!TEX root = ../dissertation.tex
\begin{savequote}[75mm]
A language that doesn't affect the way you think about programming is not worth knowing.
\qauthor{Alan J. Perlis}
\end{savequote}

\chapter{Lucy Programming Language}
The Lucy programming language is a dynamic type language with static type checking supported. The goal of Lucy language is to provide a elegant and safe method to ensure the correctness of a program. Similar to python, Lucy provides a run time type checking system to ensure each operation is done correctly. Meanwhile, inspired by TypeScript, Lucy provides static type check to improve the robustness of the program. And every thing in Lucy is passed by value, even if the parameter is an array.
The following sections will first give an overview of the syntaxes and then describe how a Lucy program will be organized. We also discuss the benefits and trade-offs of the syntaxes of Lucy. In the last part of this chapter, we will discuss how the Lucy compiler and linker works and we will discuss how this method improve the compilation speed of the Lucy program.


\section{A Tour with Lucy}
Tradition suggests that the first program in a new language should print the words "Hello World!" on the screen. In Lucy Programming Language, it can be done with invoking the print function from the std library.
\begin{lstlisting}
import "std"

func main() {
  std::print("Hello World!")
}
\end{lstlisting}
If you have written code in C or C++, this code will be very familiar to you. The Lucy codes starts from the main function, which is very similar to C programming language, and it will execute the code line by line. Moreover, unlike C and C++, Lucy does not require semicolons at the end of every statement.

Lucy does not requires the main function returns a int number as the program's exiting code and in fact, the virtual machine will detect the return statement during run time and return a none value if the function does not return anything. The detailed description of the function behavior will be introduced in function section. Though Lucy is a dynamic type programming language, i.e. the type of the the variable can be changed during run time, Lucy still requires compiling and linking to the Lucy X assembly code so that it can be interpreted by Lucy Virtual Machine. The mechanism behind Lucy, Lucy X and its virtual machine will be discussed in compilation and linking section. Lucy aims to provide a way to mix static type and dynamic type. The front-end semantic checker will ensure the correctness of the static type in static assignment, and the virtual machine will ensure the correctness of the assignment of dynamic type. The trade-offs of this syntax design and the implementation will be discussed in the syntax design section and the implementation chapter.

\subsection{Simple Value}
Lucy uses var keyword to create a variable and the initial value of the variable will be set to none if no type keyword is given.
\begin{lstlisting}
var a             // a is a optional type variable with none value
var a = 10        // a is a number type variable with number value 10
var a:number      // a is a number type variable with number value 0
var a:number = 10 // a is a number type variable with number value 10
\end{lstlisting}
A comma can be used to separate the var declaration and to assign the variable a static type, type keyword should be present after every single declaration. For example:
\begin{lstlisting}
var a, b:number   // a is optional type but b is number type
var a:number, b:number // both a and b are number type
\end{lstlisting}
The default value of the build types are set as following:
\begin{itemize}
  \item number: 0
  \item boolean: false
  \item string: ""
  \item array: []
  \item optional: none
\end{itemize}

\subsection{Array}
In Lucy, array is a primitive type and is passed by value when invoking a function call. Lucy provides 3 low level instructions, getter, setter and len function, to access array items and attributes.
\begin{lstlisting}
var length = len(array)
var value = array[0]
array[0] = value
\end{lstlisting}
Inside the array, all items will be considered as optional type. So an two dimensional arrays can be implemented by an array that contains another one dimensional array. Array also can be represented as a literal value. For example:
\begin{lstlisting}
var array = [none, 0, false, ""]
\end{lstlisting}
The + operator is used to concatenate two arrays and the result will be a new array that contains all elements of these two. When copying values to the new array, deep copy strategy is used so that every value inside these two arrays will be copied to the result array. For example:
\begin{lstlisting}
var result = ["hello", 0] + [0, [1, "world"]]
result == ["hello", 0, 0, [1, "world"]]
\end{lstlisting}

\subsection{Type}
Lucy is a dynamic type programming language, which means the type of the variable can be changed during the runtime. But Lucy also provides a static type checking system which introduces the optional type the the language. In Lucy, a variable without associating a type keyword will be considered as an optional type value. Only the type of the variables of the optional types can be changed during runtime. For example:
\begin{lstlisting}
var a = 0      // a is a variable of optional type
a = "string"
a = false
\end{lstlisting}
Moreover, a variable of optional type can be assigned with any types but a variable of a fixed type can only be assigned with the value of that type. For example:
\begin{lstlisting}
var a, b:number  // a is optional but b is number
a = b            // valid
b = a            // invalid; type error
\end{lstlisting}
Optional type will propagate to the expression when connecting two different values:
\begin{lstlisting}
var a = 0, b:number = 0
var c = a + b        // c is optional type
\end{lstlisting}
The assignment rule is also used in function parameter. A number value can be passed to a function with number type or optional type parameter. An optional value can only be passed to functions with optional type parameter. For example:
\begin{lstlisting}
func add(a, b) {
  return a + b
}

func add_n(a: number, b: number): number {
  return a + b
}

func add_s(a, b:number): string {
  return std::string(a) + std::string(b)
}

func add_s_invalid(a, b:number): string {
  return a + std::string(b)      // invalid; optional propagation
}

func main() {
  var a = add("hello", "world")  // valid
  var b = add(0, 1)  // valid    // invalid
  var c = add_n("hello", "world") // invalid
  var d = add_n(0, 1)             // valid
}
\end{lstlisting}
In the function definition, if there is no type keyword after the function signature, Lucy will treat it as optional type. If the function returns a value, it will simply return the result to the caller. If the function does not return any thing, the function will will return a none to the caller. The detailed behavior of the function will be discussed in the function section.

\subsection{Control Flow}
Lucy uses \texttt{if} for conditional control flow and \texttt{while} for loop conditional flow. The \texttt{if} statement will first check the value of the condition expression and only if the expression has a boolean value true, the statements inside if block will be executed. In this case, else keyword is used for handling the other cases. Braces around the body are required to clarify the bound of the statements.
\begin{lstlisting}
if expression {
  // statements if expression is true
} else {
  // statements if expression is false
}
\end{lstlisting}
\texttt{if} statement can also take a statement before checking the expression's value like the traditional \texttt{for} loop in C language.
\begin{lstlisting}
if var a = add(10, 20); a == 30 {
  // statements if expression is true
} else {
  // statements if expression is false
}
\end{lstlisting}
The \texttt{while} is very similar to the \texttt{if} statement. It checks the expression value every time before executing the statements inside the while loop. Only the condition expression is boolean type and equals true, it will execute the codes inside the loop.
\begin{lstlisting}
while expression {
  // statements if expression is true
}
\end{lstlisting}
Like \texttt{if} statement, the \texttt{while} can take a statement before checking the expression's value as well. But this statement will be only executed once.
\begin{lstlisting}
while a = add(10, 20); a < 50 {
  // statements if expression is true
}
\end{lstlisting}
In the above code, the value a will be evaluated once and in the second loop, the \texttt{while} statement will only checks the value of \texttt{a < 50}.

\subsection{Function}
Lucy uses \texttt{func} to define a function. In Lucy, every function will returns a value. The type keyword can be omitted if the function returns an optional value. If the function returns a none optional value, the type keyword must be present.
\begin{lstlisting}
func result() {
  return none
}

func result_n(): number {
  return 0
}
\end{lstlisting}
If the function returns an optional value, then the function does not requires a return statement in every branch. If the return statement does not present, a none value will be returned.
\begin{lstlisting}
func result() {}

func main() {
  var a = result()
  // a is optional type with a none value
}
\end{lstlisting}
But if the function returns a none optional value, a return statement will be required in every branch inside the function.
\begin{lstlisting}
func result():number {
  if true {
    return 0
  } else {
    return 1    // return is required
  }
}

func main() {
  var a = result()
  // a is number type with number value 0
}
\end{lstlisting}
When declaring a function, the type keyword of parameter can be omitted if the the parameter is optional type. An optional typed parameter can be assigned with any other typed value but a none optional typed parameter can only be assigned with the corresponding typed value.

\subsection{Parameter Passing}
Like a lot of other languages, invoking a function can be easily done with call the function name followed by the parameters. The only difference is that every thing in Lucy is passed by value, even if it is an array(As mentioned before, array is a primitive type in Lucy). In this case, modifying an array inside the function will not modify the real value of this array.
\begin{lstlisting}
func modify(a: []) {
  a[0] = "new value"
  return a
}

func main() {
  var a = ["hello"]
  modify(a)     // this will not modify a
  a = modify(a) // correct to do the modification
}
\end{lstlisting}


\section{Code Organization}
The Lucy program is organized by packages. A Lucy source code file shall start with the package keyword with the a string package name. For example:
\begin{lstlisting}
package "string"
\end{lstlisting}
The above code defines a string package. An executable Lucy program must contain a main module and the main function must be in the main module.
\begin{lstlisting}
package "main"
func main() {}
\end{lstlisting}
Functions inside package are directly visible to all functions inside this package even if they are in different files. For example we have following codes:
\begin{lstlisting}
// file1.ly
package "string"
func funca() {}

// file2.ly
package "string"
func funcb() {
  funca()
}
\end{lstlisting}
Since the \texttt{file1} and \texttt{file2} are in the same package, when invoke the compile to compile these two files, the Lucy compile will link these two functions together into one module so that the all functions are visible inside the package. The details of how the compiler and linker works will be discussed in the Compilation and Linking section.
\texttt{import} keyword is used to import functions from other package. for example:
\begin{lstlisting}
package "main"
import "std"
\end{lstlisting}
In the above code imports the \texttt{std} package into the main module. The imported module will be linked during the linking stage by Lucy linker. And to invoke a function inside the \texttt{std} package, Lucy uses \texttt{::} to identify the function.
\begin{lstlisting}
package "main"
import "std"

func main() {
  std::print("Hello World!\n")
}
\end{lstlisting}
When the Lucy compiler compiles the source code, when never a function is parsed, the function signature will be prefixed by the package name so that in the linking time, the function can be linked by the linker.
\begin{lstlisting}
package "string"

func funca() {} // compiles to string::funca
\end{lstlisting}
So it is fine to define a function with the same name in the imported package. A \texttt{print} function can be defined inside the \texttt{main} package and when invoking \texttt{print} directly, the \texttt{print} function inside main module will be executed and when calling \texttt{std::print}, the \texttt{print} function inside \texttt{std} package will be executed.
\begin{lstlisting}
package "main"
import "std"

func print(val: string) {
  printf("main: " + val)
}

func main() {
  print("Hello World")      // print main: Hello World
  std::print("Hello World") // print Hello World
}
\end{lstlisting}
The following example shows a sample way to organize the Lucy codes.
\begin{lstlisting}
game.ly    - package "game"
main.ly    - package "main"
message.ly - package "message"
util.ly    - package "util"
Makefile   - Makefile
\end{lstlisting}
The detailed compilation and linking strategy will be discussed in the Compilation and Linking section.


\section{Syntax Design and Trade-offs}
In this section we will discuss how Lucy syntax and its features improves the the robustness of the program. Lucy is a general purpose language and it is designed to be lightweight. The syntax of Lucy is inspired by Golang and Swift, as well as TypeScript. It tends to be simple, elegant and easy for learning. The goal of the syntax is to provide a way which can minimum the token used without losing the power of expression ability. \\
In the first subsection, we will take a look the syntactic sugar in the Lucy language and discuss how it improves the experience of coding. In the second subsection, we will discuss the advantage and disadvantage of passing by values and passing by references.

\subsection{Syntactic Sugar}
In traditional programming language like C and Java, the basic syntaxes will variable declaration, assignment, expression, if statement, loop statement. In some modern languages, pattern matching will be introduced for replacing the switch statement.
\subsubsection{Variable Declaration}
In the static type programming language, usually the type keyword cannot be omitted so that the compiler can always detect the type of the variable. But in Golang and Swift, the type keyword is suggested to be omitted if the type can be inferred from the expression. For example:
\begin{lstlisting}
var a = 0
\end{lstlisting}
The variable a is a number type variable since the type of 0 is number. Another example is the C language's variable declaration style:
\begin{lstlisting}[language=c]
int a;
\end{lstlisting}
The first style is always suggested in Golang since from the expression, it is easy to know the type of a and the initial value of a is 0. In C language's style, it is easy to know the type of a is int but the initial value is implicit. In fact, a lot of bugs caused by this style since the default value of an int variable is random in C.
A different example is Python and JavaScript's style. Since they are dynamic typed programming language and there is no need to declare the type of the variable. In Python and JavaScript, the variable declaration is just a simple assignment statement.
\begin{lstlisting}
a = 0
\end{lstlisting}
This style omits the var keyword which actually makes the code a little messy. For example, an editor with syntax highlighter can easily identify the declaration statement using the var style. But comparing with that, the single assignment style can not be easily identified by human. So considering the human readability, a var keyword is required in Lucy for declaring variables.

\subsection{Passing by Values VS Passing by References}


\section{Compilation and Linking}
Suspendisse dictum lectus a nisl ultricies, in pharetra enim dignissim. Phasellus quis justo ornare, facilisis sem ut, dapibus ipsum. Nunc sed urna pharetra magna ornare viverra sodales ut mi. Vestibulum elementum ultrices elementum. Nullam ultrices tincidunt hendrerit. Cras condimentum, urna ut mollis porta, orci magna dapibus diam, quis interdum dui quam non arcu. Curabitur id lacus ex.

Nunc feugiat pharetra pulvinar. Nullam interdum tellus sit amet sagittis gravida. Duis aliquet vitae turpis sit amet vestibulum. Vivamus risus neque, rhoncus ut lacus molestie, ullamcorper volutpat enim. Ut nunc nisi, iaculis sed nisl non, efficitur rhoncus ex. Aenean posuere nibh sed hendrerit gravida. Nullam eu justo aliquam lorem gravida volutpat sed nec dui. Praesent dictum enim ut lacus mattis venenatis. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam nisl urna, facilisis vitae efficitur quis, tristique venenatis lacus. Curabitur fringilla interdum dignissim. Nunc sapien turpis, aliquam non elit eget, lobortis cursus velit. Pellentesque pellentesque at nunc a varius. Phasellus molestie ante vitae enim viverra laoreet. Cras sem justo, interdum at gravida sit amet, lobortis sit amet leo.
\begin{lstlisting}[language=Bash]
  lucy -c files
\end{lstlisting}
