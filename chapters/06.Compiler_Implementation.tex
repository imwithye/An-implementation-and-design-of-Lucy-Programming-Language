\chapter{Compiler Implementation}
Lucy is a dynamic language with static type checking. The Lucy compiler compiles Lucy codes to Lucy X assembly codes. It translates the source codes to Lucy X assembly module object and serializes the object to a binary file. The following sections describe the compilation pipeline. In the first stages, the scanner reads in source codes and produces tokens to next stage. In the second section, we will discuss the details of the the syntax analyzer. The syntax analyzer produces an abstract syntax tree which will be validated by the semantic analyzer. In the last part of this chapter, we will discuss the implementation of the static type checking system.


\section{Lexical Analysis}
In Lucy's compiler pipeline, lexical analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an identified "meaning"). The Lucy's scanner reads in source codes and translates lexeme to the tokens. The scanner is generated by scanner generator with define the regular expressions of the tokens. The detailed regular expression's table can be retrieved in the source codes and we will discusses some special cases here. \\
In traditional programming language, statements are separated by semicolons. Lucy uses new line character and semicolon as the statement separator. A special case is the the separator in the \texttt{if} and \texttt{while} statement. These two statements may take a statement before checking the value of the condition expression and semicolon is used to separate these two parts. In this case, new line character and semicolons will be recognized as two different tokens.
\begin{lstlisting}[language=java]
[\s\t]+   { /* ignored */ }
[\r\n]+   { return token(Terminals.STMT_TAIL); }
;+        { return token(Terminals.SEMICOLON); }
\end{lstlisting}
Lucy tends to be a simple and modern language. Lucy uses both \texttt{and} and \texttt{\&\&} as its operator so that it can create more readable codes.
\begin{lstlisting}[language=java]
"!"       { return token(Terminals.NOT); }
"not"     { return token(Terminals.NOT); }
"&&"      { return token(Terminals.AND); }
"and"     { return token(Terminals.AND); }
"||"      { return token(Terminals.OR); }
"or"      { return token(Terminals.OR); }
\end{lstlisting}

\section{Syntax Analysis}



\section{Semantic Analysis}



\section{Code Generation}
