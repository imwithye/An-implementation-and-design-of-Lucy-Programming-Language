\chapter{Compiler Implementation}
Lucy is a dynamic language with static type checking. The Lucy compiler compiles Lucy codes to Lucy X assembly codes. It translates the source codes to Lucy X assembly module object and serializes the object to a binary file. The following sections describe the compilation pipeline. In the first stages, the scanner reads in source codes and produces tokens to next stage. In the second section, we will discuss the details of the the syntax analyzer. The syntax analyzer produces an abstract syntax tree which will be validated by the semantic analyzer. In the last part of this chapter, we will discuss the implementation of the static type checking system.


\section{Lexical Analysis}
In Lucy's compiler pipeline, lexical analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an identified "meaning"). The Lucy's scanner reads in source codes and translates lexeme to the tokens. The scanner is generated by scanner generator with define the regular expressions of the tokens. The detailed regular expression's table can be retrieved in the source codes and we will discusses some special cases here. \\
In traditional programming language, statements are separated by semicolons. Lucy uses new line character and semicolon as the statement separator. A special case is the the separator in the \texttt{if} and \texttt{while} statement. These two statements may take a statement before checking the value of the condition expression and semicolon is used to separate these two parts. In this case, new line character and semicolons will be recognized as two different tokens.
\begin{lstlisting}[language=java]
[\s\t]+   { /* ignored */ }
[\r\n]+   { return token(Terminals.STMT_TAIL); }
;+        { return token(Terminals.SEMICOLON); }
\end{lstlisting}
Lucy tends to be a simple and modern language. Lucy uses both \texttt{and} and \texttt{\&\&} as its operator so that it can create more readable codes.
\begin{lstlisting}[language=java]
"!"       { return token(Terminals.NOT); }
"not"     { return token(Terminals.NOT); }
"&&"      { return token(Terminals.AND); }
"and"     { return token(Terminals.AND); }
"||"      { return token(Terminals.OR); }
"or"      { return token(Terminals.OR); }
\end{lstlisting}


\section{Syntax Analysis}
Syntactic analysis is the process of analyzing symbols that produced by the scanner, conforming to the rules of a formal grammar. The Lucy's parser is generated by a LALR parser generator which defines context free grammar and a set of semantic actions.

\subsection{Abstract Syntax Tree}
The abstract syntax tree, or just syntax tree, is a tree representation of the abstract syntactic structure of the Lucy source code. Each node of the tree denotes a construct occurring in the Lucy source code. \\
\subsubsection{Module}
The Lucy abstract syntax tree starts from the \texttt{module} node. Source code inside one package will be compiled into one \texttt{module} and will be translated to \texttt{module} in Lucy X assembly language. The \texttt{module} node is formed by 1. name, 2. imports and 3. functions. The module name is parsed from the \texttt{package} keyword from Lucy source codes. \texttt{imports} and \texttt{functions} are two arrays that hold the imported module name and defined functions. \\
\begin{forest}
[Module
  [Imports[Import[Module Name]][Import[Module Name]][Import[Module Name]]]
  [Functions[Function][Function][...]]
]
\end{forest} \\
\subsubsection{Import}
The \texttt{import} node is nothing more than a string of the imported module name. The imported package will be checked in the linking stage. The details will be described in the Linker Implementation chapter.
\subsubsection{Function}
The \texttt{function} node is formed by 1. name, 2. parameter list, 3. return type, 4. statements. The \texttt{function} node will be transformed into subroutines in the Lucy X assembly language. Parameter and statment list are two arrays that hold the parameter definitions and the statements. \\
\begin{forest}
[Function
  [Name]
  [Parameters[Parameter[Var[Name][Type]]][Parameter[Var[Name][Type]]]]
  [Statements[Statement][Statement][...]]
]
\end{forest} \\
\subsubsection{Parameter}
The \texttt{parameter} node is same as a variable declaration node, which is formed by 1. name and 2. type. The \texttt{parameter} type will only be checked during the sematic analysis time and during the code generation time, the type will be ommitted. \\
\begin{forest}
[Parameter
  [VarName]
  [VarType]
]
\end{forest} \\
\subsection{Expression}
In the abstract syntax tree, a Lucy expression is an abstract node which could be 1. Binary Expression, 2. Literal, 3. Var Name and  4. Call expression. The \texttt{Binary Expression} is an abstract node in the abstract syntax tree which is formed by the left expression and right expression. \\
\begin{forest}
[Add Expression
  [VarName [a]]
  [NumberLiteral [10]]
]
\end{forest} \\
The above node is a binary expression node in the abstract syntax tree. The left hand side expression is an expression node of \texttt{Var Name} while the right hand side expression is an expression of \texttt{Number Literal}.
\subsubsection{Statement}
In the abstract syntax tree, a Lucy statement is an abstract node which could be 1. Var Definition, 2. Assignment, 3. If Else, 4. While, 5. Return and 6. Call statement. \\
The Var Definition statement is formed by a \texttt{var} keyword var name and var type. \\
\begin{forest}
[VarDefinition
  [VarName]
  [VarType]
]
\end{forest} \\
The \texttt{Assignment} statement is formed by \texttt{VarName} and \texttt{Expression}. \\
\begin{forest}
[Assignment
  [VarName]
  [Expression]
]
\end{forest} \\
The \texttt{IfElse} statement is formed by \texttt{Expression} and \texttt{If} statement block and \texttt{Else} statement block. \\
\begin{forest}
[IfElse
  [Expression]
  [IfStatements [Statement][Statement][...]]
  [ElseStatements [Statement][Statement][...]]
]
\end{forest} \\
The \texttt{While} statement is formed by \texttt{Expression} and \texttt{loop} statement block. \\
\begin{forest}
[While
  [Expression]
  [LoopStatements [Statement][Statement][...]]
]
\end{forest} \\
Node that in the Lucy Programming language chapter we discussed the syntactic sugars like the \texttt{for} loop, it is directly translated into while loop by adding the first and last statement. \\
The \texttt{Return} statement is formed by a \texttt{return} keyword and an optional expression. \\
\begin{forest}
[Return
  [Expression]
]
\end{forest} \\
The \texttt{Call} statement is just a function call which invokes the function names. \\
\begin{forest}
[Call
  [FunctionName]
  [Parameters[Parameter][Parameter][...]]
]
\end{forest} \\
\section{Semantic Analysis}



\section{Code Generation}
