%!TEX root = ../dissertation.tex
\begin{savequote}[75mm]
Because I want to know how it works.
\qauthor{Jeff Duntemann, Assembly Language Step-by-Step: Programming with Linux}
\end{savequote}

\chapter{Lucy X Assembly Language}
Lucy programming language is compiled and linked to a module in Lucy X assembly language. The Lucy X assembly language will be finally interpreted by Lucy Virtual Machine. This chapter first gives an overview of the Lucy X assembly language and then gives a formal definition of the Lucy X assembly code. Finally we will discuss how the Lucy X assembly code will be organized.

\section{Overview}
The Lucy X assembly language is inspired by MIPS assembly language and it provides dynamic type checking and scope inheritance. The Lucy X assembly language is formed by modules and routines and it stats executing from the main subroutine.

\subsection{Goal of Lucy X Assembly Language}
Duis interdum, dolor viverra placerat scelerisque, dui sem sodales ex, feugiat vehicula augue quam sit amet justo. Quisque rutrum elementum efficitur. Aliquam turpis justo, posuere eget sagittis at, vehicula in felis. Ut a dui non magna efficitur ullamcorper non et sapien. Integer dui neque, egestas posuere sem vestibulum, mollis facilisis justo. In gravida, leo nec tincidunt sollicitudin, ligula ligula dignissim nibh, et accumsan justo tellus et mi.

\subsection{Design Principles}
Duis interdum, dolor viverra placerat scelerisque, dui sem sodales ex, feugiat vehicula augue quam sit amet justo. Quisque rutrum elementum efficitur. Aliquam turpis justo, posuere eget sagittis at, vehicula in felis. Ut a dui non magna efficitur ullamcorper non et sapien. Integer dui neque, egestas posuere sem vestibulum, mollis facilisis justo. In gravida, leo nec tincidunt sollicitudin, ligula ligula dignissim nibh, et accumsan justo tellus et mi.

\subsection{Differences between Java Byte Code}
Duis interdum, dolor viverra placerat scelerisque, dui sem sodales ex, feugiat vehicula augue quam sit amet justo. Quisque rutrum elementum efficitur. Aliquam turpis justo, posuere eget sagittis at, vehicula in felis. Ut a dui non magna efficitur ullamcorper non et sapien. Integer dui neque, egestas posuere sem vestibulum, mollis facilisis justo. In gravida, leo nec tincidunt sollicitudin, ligula ligula dignissim nibh, et accumsan justo tellus et mi.

\section{Well-Formedness}
Integer vel neque elit. Quisque auctor eros nisl, nec lobortis magna ultricies a. Maecenas ac ligula in nisl placerat congue. Cras sodales ante et tincidunt euismod. Duis suscipit magna vitae velit accumsan ornare. Aenean lobortis cursus lacus at malesuada. Nam vel dictum eros. Nam feugiat maximus ligula vitae tempus. Maecenas semper mauris pharetra quam pretium, vel lacinia risus egestas. Suspendisse ultrices risus non tincidunt commodo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Maecenas dignissim porta tellus. Cras finibus, nisi cursus laoreet efficitur, lacus eros sagittis enim, vitae volutpat ipsum ante eu sapien. Cras auctor nec diam eu gravida. Maecenas id mauris ornare, pulvinar augue ac, tempor est. Fusce vitae tortor ut augue volutpat consequat nec vel tortor.


\section{Identifiers}
Lucy X identifiers come in two basic types: global and local. Global identifiers are subroutines, global variables and local identifiers are the local variables inside a subroutine. The identifier can be any strings which matches regular expression $[\$a-zA-Z]+[a-zA-Z0–9._]*$. The identifier is used to retrieve registers from Lucy virtual machine and the value inside the target register can be either Number, Boolean or String. \\
Examples are shown below:
\begin{lstlisting}[language=LucyX]
; Add two numbers
mv left 10
mv right 20
mv result 0
add result left right

; Sub two numbers
mv diff 0
sub diff left right
\end{lstlisting}
If the identifier is not defined before referenced, the virtual machine will define a new register in the virtual machine and if the identifier has been defined twice, the virtual machine will throw an Overdefined Exception instead.


\section{Scope}
Each subroutine has its own scope in Lucy virtual machine. Subroutines are able to access the global scope and if the identifier can not be retrieved from its own scope, Lucy virtual machine will keep looking for the definition in its parent scope until the module’s root scope. If the identifier does not present in any scope, an Undefined Exception will be thrown but only the identifier has been defined in current scope, the Overdefined Exception will be thrown. \\
Examples are shown below:
\begin{lstlisting}[language=LucyX]
mv result 0

sum {
  pop a
  pop b
  add result a b
}

main {
  mv a 10
  mv b 12
  push a
  push b
  call sum
  put result
}
\end{lstlisting}
It can be executed correctly since the result identifier is defined at the global scope and it can be retrieved by any subroutines.
An example with Undefined Exception and Overdefined Exception:
\begin{lstlisting}[language=LucyX]
mv result 0

sum {
  pop a
  pop b
  add result a b
}

sum {}        ; Overdefined

main {
  mv a 10
  mv b 12
  push a
  push b
  call sum
  put result
  call div    ; Undefined
}
\end{lstlisting}


\section{Instruction Style}
Nunc iaculis sollicitudin vehicula. Morbi sollicitudin scelerisque lectus vel dapibus. Aliquam congue, lorem fermentum auctor congue, quam leo semper lectus, nec mattis justo justo eu massa. Duis vehicula dapibus purus sit amet elementum. Sed aliquet efficitur laoreet. Donec vel lectus turpis. Nullam scelerisque, sem quis pellentesque porttitor, odio lorem ullamcorper lectus, sed consectetur lacus neque at ipsum. Sed faucibus, magna at volutpat rhoncus, ex arcu blandit enim, at fringilla leo felis nec ante. Proin id orci sit amet ante volutpat interdum vitae eu elit. Ut eu sapien ante. Etiam placerat, velit ac vulputate volutpat, diam enim vehicula metus, ut sagittis augue odio vitae purus.

\subsection{Single Static Assignment Form}
Curabitur facilisis vestibulum arcu nec convallis. Sed porta, diam non fermentum commodo, enim lectus consequat leo, non vulputate nisl massa eu nulla. Suspendisse mollis suscipit blandit. Phasellus cursus ante faucibus interdum pulvinar. Quisque nec vulputate urna, eget sodales justo. Quisque euismod ligula luctus leo hendrerit, id pretium tellus pharetra. Phasellus ac arcu nec metus ultricies molestie. Phasellus eros erat, lobortis non tellus in, aliquam molestie lectus. Donec interdum metus eu sapien hendrerit, eu iaculis nisl rutrum. Pellentesque leo felis, elementum a luctus id, venenatis ut quam.

\subsection{Special Cases}
Integer non est egestas, blandit magna sed, molestie eros. Quisque commodo velit id sapien ornare fringilla. Praesent cursus molestie odio non tempor. Donec at sem id dolor semper pulvinar sit amet a est. Sed id nulla justo. Curabitur nibh nulla, luctus vel scelerisque id, hendrerit id libero. Phasellus vulputate odio pharetra odio venenatis, a efficitur nulla gravida.


\section{High Level Structure}
\subsection{Module Structure}
Lucy X assembly language is formed by modules. In Lucy programming language, the package will be directly transformed to a Lucy X module. Each Lucy X module has a module name as its identifier and is formed by global instructions and subroutines. A module with main subroutine is an executable module and the main subroutine is its entry point. Inside the module, subroutines are identified by its name and there is no two routines sharing the same name. Modules can be linked together by Lucy linker only if the target module is a main module or the two modules are sharing the same module name, i.e. they are compiling from two different files within the same package.

\subsection{Subroutine Structure}
Lucy X modules are formed by subroutines and the main subroutine will be the entry of the whole program. As a low level assembly code, the subroutine does not provide arguments and the arguments will be retrieved from the stack of the virtual machine. \\
The code transformation is shown below:
\begin{lstlisting}[language=LucyX]
func sum(a, b) {
  return a + b
}

func main() {
  result = sum(10, 10)
}

; The equivalent Lucy X assembly code

sum {
  pop a
  pop b
  add a a b
  push a
  ret
}

main {
  push 10
  push 10
  call sum
  pop result
}
\end{lstlisting}
Before calling a subroutine, the caller shall push the parameters to the stack and invoke the subroutine. The target subroutine will pop the parameter from the stack and save it to the local registers. Then it performs code inside the subroutine. The Return instruction will stop executing the subroutine and go back to the callee, and before the return instruction, the subroutine shall push the result to the stack and the callee will pop it from the stack.
The scope of Goto instruction and Branches instruction will also be limited inside the subroutine. All jump instruction will jump to the line of the target instruction but the line number is limited inside the subroutine. For example:
\begin{lstlisting}[language=LucyX]
sub {
  pop a
  pop b
  les cmp a b
  beq cmp 11
  sub result a b
  push result
  ret
  sub result b a
  push result
  ret
}
\end{lstlisting}
The BEQ instruction will be limited inside the sub subroutine so the front end code generator can generate codes by subroutines.
