%!TEX root = ../dissertation.tex
\begin{savequote}[75mm]
If a machine is expected to be infallible, it cannot also be intelligent.
\qauthor{Alan Turing}
\end{savequote}

\chapter{Lucy Virtual Machine}
Lucy Programming Language(or Lucy) is a dynamic language which runs the code over Lucy Virtual Machine. The goal of the Lucy Virtual Machine is to provide a generic platform so that the source codes of Lucy can be interpreted over it. Lucy Virtual Machine is a single thread virtual machine and driven by a small set of instructions, Lucy X assembly language. Moreover, the Lucy Virtual machine provides unlimited registers, routine scope isolation and dynamic type checking. In this chapter, we will discuss the design of the Lucy virtual machine. First we will discuss the the goal of Lucy virtual machine and the design principle. Then we will compare the Lucy virtual machine with the Java virtual machine. In the second part of this chapter, we will discuss how the register and scope isolation works and in the last part of this chapter, we will discuss how modules and routines are executed by the virtual machine.

\section{Overview}
The Lucy virtual machine(Lucy VM) is the a low level virtual machine which is driven by Lucy X assembly languages. Lucy virtual machine is an open protocol which can be implemented in any programming language. Lucy VM tends to be a purely logical system. Lucy VM does not simulate cache and main memory, instead, it provides unlimited registers to hold values and unlimited stack memory to perform function calls. Registers in Lucy VM stores a value object which can be number, string, boolean, array or none. The type of the value will be checked during run time to ensure the correctness of every operation.

\subsection{Goal of Lucy Virtual Machine}
Lucy virtual machine is a general purpose virtual machine, and it simulates the real computer in an abstract level. Lucy VM tends to be as simple as possible. The goal of Lucy VM is to provide a completed virtual system without increasing the complexity. Lucy VM is designed for Lucy X and driven by Lucy X only, which is a good start point for those who are interested in compiler techniques.

\subsection{Differences between Java Stack Machine}
A Java virtual machine (JVM) is an abstract computing machine that enables a computer to run a Java program. Java virtual machine is a stack machine and driven by Java byte code. Unlike Lucy VM, Java uses stack to hold result of the instruction. Operands shall be pushed into the stack before calling the operator. After calculating the result, operand will be popped from the stack memory. Moreover, Java byte code is a type sensitive language while registers in Lucy VM are dynamic typed.


\section{Register and Its Scopes}
As we mentioned last chapter, Lucy X assembly uses unlimited registers and scope isolation for the subroutines. In Lucy VM, registers are nothing more than a value container. It holds values and it can be addressed by the register name. Registers cannot share the same name in the same scope. Subroutines are able to access the global scope and if the identifier can not be retrieved from its own scope, Lucy VM will keep looking for the definition in its parent scope until the moduleâ€™s root scope. \\
The \texttt{Register} class is very simple and straightforward:
\begin{lstlisting}[language=java]
public class Register {
    private Value value;

    public Register(Value value) {
        this.assignValue(value);
    }

    public Value getValue() {
        return this.value;
    }

    public Type getType() {
        return this.value.getType();
    }

    public Register assignValue(Value value) {
        assert value != null;
        this.value = value.copy();
        return this;
    }
}
\end{lstlisting}
When assigning a value to the register, \texttt{copy} method will be called to create a new instance of the value, in which case, Lucy and Lucy X are all passed by values. Note that even though Lucy will be compiled to Lucy X and the transformation tends to be in SSA form, which is called well-formed Lucy X codes, it does not mean Lucy X is a SSA language and the register in Lucy VM is still mutable. \\
The \texttt{Scope} class is a modified version of the \texttt{HashMap}. It contains a \texttt{HashMap} and a parent scope's reference.
\begin{lstlisting}[language=java]
public class Scope<K, V> implements Serializable {
  private HashMap<K, V> scope;
  private Scope<K, V> parent;

  public Scope(Scope<K, V> parent) {
    this.scope = new HashMap<K, V>();
    this.parent = parent;
  }

  public Scope set(K key, V value) throws OverdefinedException {
    assert key != null;
    assert value != null;
    if (this.isDefined(key)) {
      throw new OverdefinedException(key, this);
    }
    return this.set(key, value);
  }

  public V get(K key) throws UndefinedException {
    assert key != null;
    V value = this.scope.get(key);
    if (value == null) {
      if (this.parent == null) {
        throw new UndefinedException(key, this);
      } else {
        return this.parent.get(key);
      }
    } else {
      return value;
    }
  }
}
\end{lstlisting}
The \texttt{set} and \texttt{get} method in \texttt{Scope} class prevents setting the already defined key or getting an undefined key. The \texttt{get} method will keep looking until it reaches the root scope(i.e. the one without parent scope). When the given key is not in all the scopes, an \texttt{UndefinedException} will be thrown. \\
The Lucy VM will create a global scope which stores the global register names and when executing each subroutine, a new local scope will be created to store the registers declared inside the subroutine.
\begin{lstlisting}[language=java]
public class Machine {
  private int pc;
  private Scope<String, Register> rootScope;
  private Stack<Value> memoryStack;
}
\end{lstlisting}
The program counter is a pointer which points to the next instruction and memory stack is reserved for parameter passing.

\section{Routine Execution}
Curabitur feugiat consectetur venenatis. Praesent ornare tellus tristique dictum suscipit. Donec blandit sodales leo, sed tempor turpis tristique at. Aenean convallis eros lacus. Maecenas commodo sem convallis, mollis enim quis, molestie est. Integer id condimentum arcu. In condimentum non diam nec aliquet. Sed volutpat quam at purus porttitor, at faucibus ante viverra. Nunc et arcu ac nunc tempus mollis eget at sem.

Nullam euismod a ipsum feugiat maximus. Maecenas vehicula commodo lacinia. Donec nec tincidunt dolor. Donec lectus mauris, molestie in ipsum at, maximus fringilla ligula. Fusce consequat mi odio, nec malesuada ante tristique a. In hac habitasse platea dictumst. Nulla efficitur malesuada diam vel consequat. Pellentesque augue nisi, ornare et eros sed, lobortis condimentum dui. Ut eu placerat sem, vitae viverra urna. Maecenas rutrum odio et luctus cursus. Sed blandit nisi id leo fermentum blandit. Phasellus convallis vulputate turpis, pretium mattis nibh suscipit vitae. Nullam porta ligula eu leo commodo, vitae blandit lorem efficitur. Nunc pellentesque sagittis dolor maximus feugiat. Phasellus luctus turpis sem, at lacinia odio ullamcorper eu. Praesent tellus odio, condimentum non vehicula id, consectetur ut nunc.


\section{Module Execution}
Curabitur dictum, ex quis tristique euismod, nibh libero tempus augue, et tempus risus arcu sit amet ante. Quisque venenatis, tortor lacinia pellentesque auctor, mi felis pretium lectus, eget feugiat magna ante sed lacus. Nullam in aliquam urna. Etiam et ultricies purus. Integer quis efficitur urna. Sed faucibus elit vitae massa aliquam venenatis. Pellentesque imperdiet elit eget neque feugiat pretium. Aenean et nisl sem. Sed quam neque, euismod posuere pretium quis, tincidunt ac magna. Nunc mattis libero tortor, vitae rhoncus dolor cursus in. Cras consequat non mi sed scelerisque. Donec vitae neque at mauris ullamcorper pretium. Aenean sit amet venenatis leo. Fusce id risus eget quam faucibus lobortis eget quis dui. Pellentesque a massa augue. Nulla feugiat, nisi id maximus porttitor, odio lectus rhoncus ipsum, ut placerat nibh mi vitae magna.
